<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Disparador ‚Äî Print compacto com c√≥pia autom√°tica</title>

<!-- Depend√™ncias -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/exceljs@4.4.0/dist/exceljs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.4/dist/tesseract.min.js"></script>

<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
  
  :root{
    --bb-azul:#0033a0;
    --bb-azul-dark:#002780;
    --bg:#f6f7fb;
    --card:#fff;
    --muted:#6b7280;
    --text:#111827;
    --border:#e5e7eb;
    --radius:16px;
    --shadow:0 4px 16px rgba(3,7,18,.08);
    --shadow-lg:0 8px 32px rgba(3,7,18,.12);
  }
  
  *{box-sizing:border-box;margin:0;padding:0}
  
  body{
    margin:0;
    font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    background:linear-gradient(135deg,#f0f3ff 0%,#f8fafc 100%);
    color:var(--text);
    line-height:1.6;
    min-height:100vh;
  }
  
  header{
    padding:24px 32px;
    background:linear-gradient(135deg,var(--bb-azul) 0%,var(--bb-azul-dark) 100%);
    color:#fff;
    display:flex;
    align-items:center;
    justify-content:space-between;
    box-shadow:var(--shadow-lg);
    position:sticky;
    top:0;
    z-index:100;
  }
  
  header h1{
    margin:0;
    font-size:22px;
    font-weight:700;
    letter-spacing:-.02em;
  }
  
  header small{
    display:block;
    margin-top:4px;
    opacity:.85;
    font-size:13px;
    font-weight:400;
  }
  
  .pill{
    display:inline-flex;
    gap:6px;
    padding:6px 14px;
    border-radius:999px;
    font-size:12px;
    font-weight:600;
    background:rgba(255,255,255,.15);
    backdrop-filter:blur(10px);
    border:1px solid rgba(255,255,255,.2);
  }
  
  .container{
    max-width:1400px;
    margin:32px auto;
    padding:0 24px;
  }
  
  .grid{
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(500px, 1fr));
    gap:20px;
  }
  
  @media (max-width: 1100px){
    .grid{grid-template-columns:1fr}
  }
  
  .card{
    background:var(--card);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:24px;
    border:1px solid var(--border);
    transition:box-shadow .2s ease;
  }
  
  .card:hover{
    box-shadow:var(--shadow-lg);
  }
  
  .card h2{
    margin:0 0 8px;
    font-size:18px;
    font-weight:700;
    color:var(--bb-azul);
    display:flex;
    align-items:center;
    gap:8px;
  }
  
  .card h2::before{
    content:'';
    display:inline-block;
    width:4px;
    height:20px;
    background:var(--bb-azul);
    border-radius:2px;
  }
  
  .helper{
    font-size:13px;
    color:var(--muted);
    margin-top:8px;
    line-height:1.5;
  }
  
  .helper b{
    color:var(--bb-azul);
    font-weight:600;
  }
  
  .toolbar{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
    margin-top:12px;
  }
  
  textarea,
  input[type="text"],
  select{
    width:100%;
    padding:12px 14px;
    border:1.5px solid var(--border);
    border-radius:12px;
    background:#fff;
    font:inherit;
    font-size:14px;
    transition:all .2s ease;
    outline:none;
  }
  
  textarea:focus,
  input[type="text"]:focus,
  select:focus{
    border-color:var(--bb-azul);
    box-shadow:0 0 0 3px rgba(0,51,160,.08);
  }
  
  textarea{
    min-height:140px;
    resize:vertical;
    font-family:'SF Mono',Monaco,Consolas,monospace;
    font-size:13px;
  }
  
  .btn{
    appearance:none;
    border:none;
    background:var(--bb-azul);
    color:#fff;
    padding:10px 18px;
    border-radius:10px;
    font-weight:600;
    font-size:14px;
    cursor:pointer;
    transition:all .2s ease;
    white-space:nowrap;
  }
  
  .btn:hover:not(:disabled){
    background:var(--bb-azul-dark);
    transform:translateY(-1px);
    box-shadow:0 4px 12px rgba(0,51,160,.25);
  }
  
  .btn:active:not(:disabled){
    transform:translateY(0);
  }
  
  .btn:disabled{
    opacity:.5;
    cursor:not-allowed;
  }
  
  .btn.ghost{
    background:#fff;
    color:var(--text);
    border:1.5px solid var(--border);
  }
  
  .btn.ghost:hover:not(:disabled){
    background:#f9fafb;
    border-color:#d1d5db;
    transform:translateY(-1px);
    box-shadow:0 2px 8px rgba(0,0,0,.06);
  }
  
  .btn.dark{
    background:#0f172a;
  }
  
  .btn.dark:hover:not(:disabled){
    background:#1e293b;
  }
  
  .table-wrap{
    border:1.5px solid var(--border);
    border-radius:12px;
    overflow:auto;
    background:#fff;
    max-height:320px;
  }
  
  table{
    width:100%;
    border-collapse:collapse;
    font-size:13px;
  }
  
  th,td{
    padding:10px 12px;
    border-bottom:1px solid #f1f5f9;
    text-align:left;
    white-space:nowrap;
  }
  
  tbody tr:hover{
    background:#f9fafb;
  }
  
  thead th{
    background:#f8fafc;
    font-size:11px;
    color:#64748b;
    text-transform:uppercase;
    letter-spacing:.05em;
    font-weight:700;
    position:sticky;
    top:0;
    z-index:10;
    border-bottom:2px solid var(--border);
  }
  
  .list{
    display:grid;
    gap:16px;
  }
  
  .msg{
    border:1.5px solid var(--border);
    border-radius:12px;
    padding:16px;
    background:#fcfcff;
    transition:all .2s ease;
  }
  
  .msg:hover{
    border-color:#cbd5e1;
    box-shadow:0 2px 12px rgba(0,0,0,.04);
  }
  
  .muted{color:var(--muted)}
  
  .badge{
    font-size:11px;
    padding:4px 10px;
    border-radius:999px;
    background:#eef2ff;
    color:#4338ca;
    font-weight:600;
    white-space:nowrap;
  }
  
  .badge.success{
    background:#ecfdf5;
    color:#065f46;
  }
  
  .badge.warning{
    background:#fef3c7;
    color:#92400e;
  }
  
  .right{margin-left:auto}
  
  .ok{
    background:#ecfdf5;
    border:1.5px solid #bbf7d0;
    color:#065f46;
    border-radius:10px;
    padding:8px 12px;
    font-size:13px;
    font-weight:600;
  }
  
  .err{
    background:#fef2f2;
    border:1.5px solid #fecaca;
    color:#991b1b;
    border-radius:10px;
    padding:12px;
    font-size:13px;
    font-weight:600;
  }
  
  .row{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
  }
  
  .small{font-size:12px}
  
  .sheet-paste{
    width:100%;
    min-height:180px;
    border:2px dashed #94a3b8;
    border-radius:12px;
    background:#fafbfc;
    padding:12px;
    overflow:auto;
    font-family:'SF Mono',Monaco,Consolas,monospace;
    font-size:12px;
    transition:all .2s ease;
  }
  
  .sheet-paste:focus{
    outline:none;
    border-color:var(--bb-azul);
    background:#fff;
    box-shadow:0 0 0 3px rgba(0,51,160,.08);
  }
  
  .ghost-table{
    max-height:240px;
    overflow:auto;
    border:1.5px solid var(--border);
    border-radius:10px;
    margin-top:10px;
  }
  
  .richmsg p{margin:.5em 0}
  
  .separator{
    margin:12px 0;
    height:1px;
    background:linear-gradient(90deg, transparent, var(--border), transparent);
  }
  
  .imgwrap{
    display:flex;
    flex-direction:column;
    gap:10px;
  }
  
  .richmsg img{
    max-width:100%;
    height:auto;
    border:1.5px solid var(--border);
    border-radius:10px;
    box-shadow:0 2px 8px rgba(0,0,0,.06);
  }
  
  .rte-bar{
    display:flex;
    gap:8px;
    margin:10px 0;
  }
  
  .rte-btn{
    border:1.5px solid var(--border);
    background:#fff;
    border-radius:8px;
    padding:8px 12px;
    cursor:pointer;
    font-weight:600;
    font-size:13px;
    transition:all .2s ease;
  }
  
  .rte-btn:hover{
    background:#f9fafb;
    border-color:#d1d5db;
  }
  
  .rte-btn.active{
    border-color:#c7d2fe;
    background:#eef2ff;
    color:var(--bb-azul);
  }
  
  #messageBody{
    min-height:160px;
    border:1.5px solid var(--border);
    border-radius:12px;
    padding:14px;
    background:#fff;
    overflow:auto;
    font-size:14px;
    line-height:1.7;
    transition:all .2s ease;
  }
  
  #messageBody:focus{
    outline:none;
    border-color:var(--bb-azul);
    box-shadow:0 0 0 3px rgba(0,51,160,.08);
  }
  
  #messageBody:empty:before{
    content:attr(data-placeholder);
    color:#9ca3af;
  }
  
  #messageBody p{margin:.6em 0}
  #messageBody b,#messageBody strong{font-weight:700}
  #messageBody i,#messageBody em{font-style:italic}
  #messageBody u{text-decoration:underline}
  
  .msg__head{
    display:flex;
    gap:10px;
    align-items:center;
    margin-bottom:8px;
  }
  
  .msg__toggle{
    margin-left:auto;
    font-size:12px;
    padding:6px 12px;
    border-radius:8px;
    border:1.5px solid var(--border);
    background:#fff;
    cursor:pointer;
    font-weight:600;
    transition:all .2s ease;
  }
  
  .msg__toggle:hover{
    background:#f9fafb;
  }
  
  .msg.collapsed{
    background:#f8fafc;
    border-style:dashed;
  }
  
  .msg.collapsed .msg__body{display:none}
  
  #logs{
    margin-top:10px;
    font-size:12px;
  }
  
  input[type="checkbox"]{
    width:18px;
    height:18px;
    cursor:pointer;
    accent-color:var(--bb-azul);
  }
  
  label{
    cursor:pointer;
    user-select:none;
  }
  
  code{
    background:#f1f5f9;
    padding:2px 6px;
    border-radius:4px;
    font-family:'SF Mono',Monaco,Consolas,monospace;
    font-size:12px;
    color:var(--bb-azul);
  }
  
  /* Loading state */
  .loading{
    opacity:.6;
    pointer-events:none;
    position:relative;
  }
  
  .loading::after{
    content:'';
    position:absolute;
    top:50%;
    left:50%;
    width:20px;
    height:20px;
    margin:-10px 0 0 -10px;
    border:2px solid var(--bb-azul);
    border-right-color:transparent;
    border-radius:50%;
    animation:spin .6s linear infinite;
  }
  
  @keyframes spin{
    to{transform:rotate(360deg)}
  }
  
  /* √Årea de anexo de imagem */
  .attach-area{
    border:2px dashed var(--border);
    border-radius:12px;
    padding:16px;
    background:#fafbfc;
    text-align:center;
    transition:all .2s ease;
    margin-top:12px;
  }
  
  .attach-area.dragover{
    border-color:var(--bb-azul);
    background:#eef2ff;
  }
  
  .attach-preview{
    display:none;
    margin-top:12px;
    padding:12px;
    border:1.5px solid var(--border);
    border-radius:10px;
    background:#fff;
  }
  
  .attach-preview.active{
    display:block;
  }
  
  .attach-preview img{
    max-width:100%;
    max-height:200px;
    border-radius:8px;
  }
  
  input[type="file"]{
    display:none;
  }
  
  /* OCR Progress */
  .ocr-progress{
    display:none;
    margin-top:12px;
    padding:12px;
    border:1.5px solid var(--bb-azul);
    border-radius:10px;
    background:#eef2ff;
  }
  
  .ocr-progress.active{
    display:block;
  }
  
  .progress-bar{
    width:100%;
    height:8px;
    background:#e5e7eb;
    border-radius:4px;
    overflow:hidden;
    margin-top:8px;
  }
  
  .progress-fill{
    height:100%;
    background:var(--bb-azul);
    transition:width .3s ease;
    width:0%;
  }
  
  /* Imagem colada no campo planilha */
  .sheet-paste img{
    max-width:100%;
    height:auto;
    border-radius:8px;
    margin:8px 0;
    border:1.5px solid var(--border);
  }
</style>
</head>
<body>
<header>
  <div>
    <h1>üì§ Disparador ‚Äî Print compacto</h1>
    <small>Colar como planilha ‚Ä¢ Contatos salvos ‚Ä¢ Copiar mensagem com imagem ‚Ä¢ OCR de imagens</small>
  </div>
  <div class="pill">üîí 100% local</div>
</header>

<div class="container">
  <div class="grid">
    
    <!-- Campo 1: Contatos -->
    <section class="card">
      <h2>1Ô∏è‚É£ Contatos</h2>
      <div class="helper">
        Cole tabela com cabe√ßalhos (flex√≠vel): <b>prefixo/pref/ag√™ncia</b>, <b>nome</b>, <b>email/e-mail/mail/contato</b>. 
        Prefer√™ncia expl√≠cita pela coluna <b>"nome"</b> para o nome da pessoa.
      </div>
      
      <textarea id="contactsInput" placeholder="Exemplo:
prefixo nome email
123 Maria Clara Souza maria@empresa.com
456 Jo√£o Pedro joao@empresa.com"></textarea>
      
      <div class="toolbar">
        <button class="btn" id="loadContacts">üì• Carregar contatos</button>
        <button class="btn ghost" id="clearContacts">üóëÔ∏è Limpar</button>
        <button class="btn ghost" id="refreshContacts">üîÑ Atualizar</button>
      </div>
      
      <div class="row" style="margin-top:12px">
        <input id="searchBox" type="text" placeholder="üîç Filtrar por nome, email ou prefixo..." />
        <label class="small" style="display:flex; align-items:center; gap:6px">
          <input type="checkbox" id="keepContacts"> Salvar localmente
        </label>
        <div class="right"><span id="contactStats" class="badge">0 contatos</span></div>
      </div>
      
      <div class="table-wrap" style="margin-top:12px">
        <table id="contactsTable">
          <thead>
            <tr>
              <th><input type="checkbox" id="selectAll"></th>
              <th>Prefixo</th>
              <th>Nome</th>
              <th>Email</th>
              <th>Linhas</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      
      <div id="logs" class="helper"></div>
    </section>

    <!-- Campo 2: Mensagem -->
    <section class="card">
      <h2>2Ô∏è‚É£ Mensagem</h2>
      <div class="helper">
        Personalize a sauda√ß√£o usando <b>{nome}</b> para o primeiro nome.<br>
        Ex.: <code>Ol√° {nome}, tudo bem?</code>
      </div>

      <div class="row" style="margin:12px 0">
        <input id="greetingInput" type="text" placeholder="Sauda√ß√£o (use {nome}) ‚Äî ex.: Ol√° {nome}, tudo bem?" />
        <button class="btn ghost" id="saveGreeting" title="Salvar sauda√ß√£o no navegador">üíæ Salvar</button>
      </div>

      <div class="rte-bar">
        <button class="rte-btn" data-cmd="bold" title="Negrito (Ctrl+B)"><b>B</b></button>
        <button class="rte-btn" data-cmd="italic" title="It√°lico (Ctrl+I)"><i>I</i></button>
        <button class="rte-btn" data-cmd="underline" title="Sublinhado (Ctrl+U)"><u>U</u></button>
        <button class="btn ghost right" id="refreshMsg">üîÑ Atualizar</button>
      </div>

      <div id="messageBody" contenteditable="true" data-placeholder="Escreva aqui o texto ap√≥s a sauda√ß√£o. Use os bot√µes para negrito/it√°lico/sublinhado."></div>

      <!-- √Årea de anexo de imagem -->
      <div class="helper" style="margin-top:16px">üìé <b>Anexar imagem</b> (opcional) ‚Äî ser√° enviada para todos os contatos:</div>
      
      <div class="attach-area" id="attachArea">
        <div>
          üì∑ Arraste uma imagem aqui ou 
          <label for="fileInput" style="color:var(--bb-azul); cursor:pointer; text-decoration:underline">
            clique para selecionar
          </label>
        </div>
        <div class="small muted" style="margin-top:8px">Formatos: JPG, PNG, GIF, WebP ‚Ä¢ Cole (Ctrl+V) tamb√©m funciona</div>
      </div>
      
      <input type="file" id="fileInput" accept="image/jpeg,image/png,image/gif,image/webp" />
      
      <div class="attach-preview" id="attachPreview">
        <div class="row" style="justify-content:space-between; margin-bottom:8px">
          <span class="small"><b>üìé Imagem anexada:</b></span>
          <button class="btn ghost" id="removeAttach" style="padding:4px 10px; font-size:12px">üóëÔ∏è Remover</button>
        </div>
        <img id="attachImg" alt="Pr√©via do anexo" />
        <div class="small muted" style="margin-top:8px" id="attachInfo"></div>
      </div>

      <div class="helper">A imagem (print) inclui o <b>t√≠tulo</b>, o <b>cabe√ßalho</b> e as <b>linhas do contato</b>.</div>
      
      <div style="margin-top:12px">
        <label class="muted"><b>üëÅÔ∏è Pr√©via:</b></label>
        <div class="msg" id="previewBox">
          <div class="richmsg"><p>Ol√° Fulano, tudo bem?</p><p class="muted">[sua mensagem]</p></div>
          <div class="separator"></div>
          <div class="imgwrap"><div class="muted">[Imagem do print aparecer√° aqui]</div></div>
        </div>
      </div>
      
      <div class="toolbar">
        <button class="btn" id="generateMsgs">‚ú® Gerar mensagens</button>
      </div>
    </section>

    <!-- Campo 3: Planilha -->
    <section class="card">
      <h2>3Ô∏è‚É£ Planilha ‚Äî cole texto OU imagem (Ctrl+V)</h2>
      <div class="helper">
        Cole direto do Excel/Sheets <b>ou</b> cole uma <b>imagem de tabela</b> (OCR autom√°tico busca <b>prefixo/ag√™ncia</b>). Informe um <b>T√≠tulo da planilha</b> para ir no print.
      </div>
      
      <input id="sheetTitle" type="text" placeholder="üìä T√≠tulo da planilha (ex.: Relat√≥rio por Prefixo)" style="margin-bottom:12px" />
      
      <div id="sheetPaste" class="sheet-paste" contenteditable="true" spellcheck="false"></div>
      
      <!-- Progress bar do OCR -->
      <div class="ocr-progress" id="ocrProgress">
        <div class="row" style="justify-content:space-between; align-items:center">
          <span class="small"><b>üîç Processando imagem com OCR...</b></span>
          <span class="small" id="ocrPercent">0%</span>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="small muted" style="margin-top:8px" id="ocrStatus">Inicializando...</div>
      </div>
      
      <div class="row" style="margin-top:12px">
        <label style="white-space:nowrap">Linha do cabe√ßalho:</label>
        <input id="headerRow" type="text" placeholder="1 (padr√£o)" style="width:100px">
        <button class="btn" id="usePasted">‚úÖ Usar dados colados</button>
        <button class="btn ghost" id="clearAttach" disabled>üóëÔ∏è Limpar</button>
        <button class="btn ghost" id="refreshSheet">üîÑ Atualizar</button>
        <div class="right"><span id="attachStats" class="badge warning">Sem dados</span></div>
      </div>
      
      <div id="errorBox" class="helper"></div>

      <div class="helper" style="margin-top:8px">üí° Pr√©-visualiza√ß√£o (rolagem horizontal):</div>
      <div id="sheetPreview" class="ghost-table" style="display:none"></div>

      <div class="toolbar" style="margin-top:12px">
        <button class="btn dark" id="downloadZip" disabled>üí¨ Abrir chat no Teams (teste)</button>
      </div>
      
      <div class="helper">
        <b>OCR foca em:</b> encontrar <b>prefixo</b> e/ou <b>ag√™ncia</b> para associar com os contatos.
      </div>
    </section>

    <!-- Campo 4: Sa√≠da -->
    <section class="card" style="grid-column: span 2">
      <div class="row" style="justify-content:space-between; align-items:center; margin-bottom:16px">
        <h2 style="margin:0">4Ô∏è‚É£ Mensagens geradas (copiar & colar)</h2>
        <div class="row" style="gap:10px; align-items:center">
          <label class="small" for="sortOrder">Ordenar:</label>
          <select id="sortOrder" style="width:auto">
            <option value="original" selected>Original</option>
            <option value="nome_az">Nome (A‚ÜíZ)</option>
          </select>
          <button class="btn ghost" id="refreshAll">üîÑ Atualizar tudo</button>
        </div>
      </div>
      
      <div class="helper">
        üí° "Copiar mensagem" copia HTML com imagem (quando suportado). Abra o chat e cole (Ctrl+V).
      </div>
      
      <div id="output" class="list"></div>
    </section>
    
  </div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
  'use strict';
  
  /* ========================================
     SISTEMA DE LOGS E ERROS
  ======================================== */
  const logBox = document.getElementById('logs');
  
  const log = (msg, type = 'ok') => {
    if (!logBox) return;
    const icon = type === 'ok' ? '‚úÖ' : type === 'warn' ? '‚ö†Ô∏è' : '‚ùå';
    const className = type === 'ok' ? 'ok' : 'err';
    logBox.innerHTML = `<div class="${className}">${icon} ${msg}</div>`;
    console.log(`[${type.toUpperCase()}] ${msg}`);
  };
  
  const logErr = (msg, detail = '') => {
    if (!logBox) return;
    const fullMsg = detail ? `${msg}<br><small>${detail}</small>` : msg;
    logBox.innerHTML = `<div class="err">‚ùå <b>Erro:</b> ${fullMsg}</div>`;
    console.error(`[ERROR] ${msg}`, detail);
  };
  
  // Captura erros globais
  window.addEventListener('error', e => {
    logErr('Erro de script', e?.message || 'Erro desconhecido');
  });
  
  window.addEventListener('unhandledrejection', e => {
    logErr('Promise rejeitada', e?.reason || 'Erro desconhecido');
  });

  /* ========================================
     ESTADO GLOBAL DA APLICA√á√ÉO
  ======================================== */
  let contacts = [];
  let filteredContactsIdx = [];
  let headers = [];
  let rowsAll = [];
  const groupedRowsByContact = new Map();
  const imageCacheByContact = new Map();
  
  // Estado do anexo global
  let globalAttachment = null; // { blob, dataUrl, filename, size }
  
  // Imagem colada no campo planilha (mantida para n√£o processar OCR novamente)
  let pastedSheetImage = null;

  /* ========================================
     UTILIT√ÅRIOS
  ======================================== */
  const el = (selector) => document.querySelector(selector);
  const normalizeKey = (str) => String(str || '').trim().toLowerCase();
  
  const stripAccents = (str) => 
    String(str || '')
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '');
  
  const equalsLoose = (a, b) => 
    stripAccents(a).trim().toLowerCase() === stripAccents(b).trim().toLowerCase();
  
  const debounce = (fn, ms = 250) => {
    let timer;
    return (...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => fn(...args), ms);
    };
  };
  
  const titleCaseName = (name) => {
    if (!name) return "Fulano";
    return String(name)
      .toLowerCase()
      .replace(/(^|\s)([a-z√°-√∫])/g, (m, p1, p2) => p1 + p2.toUpperCase());
  };
  
  const firstName = (name) => {
    if (!name) return "Fulano";
    const cleaned = String(name)
      .trim()
      .replace(/^(sr\.?|sra\.?|sr\(a\)\.?|dr\.?|dra\.?|prof\.?|profa\.?|mr\.?|mrs\.?|ms\.?)\s+/i, "");
    const first = cleaned.split(/\s+/)[0] || "Fulano";
    return first
      .toLowerCase()
      .replace(/(^|\s)([a-z√°-√∫])/g, (m, p1, p2) => p1 + p2.toUpperCase());
  };
  
  function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  }

  /* ========================================
     OCR COM TESSERACT.JS
  ======================================== */
  const ocrProgress = el('#ocrProgress');
  const ocrPercent = el('#ocrPercent');
  const ocrStatus = el('#ocrStatus');
  const progressFill = el('#progressFill');
  
  async function performOCR(imageFile) {
    try {
      ocrProgress.classList.add('active');
      ocrStatus.textContent = 'Inicializando OCR...';
      progressFill.style.width = '0%';
      ocrPercent.textContent = '0%';
      
      console.log('üîç Iniciando OCR na imagem (foco em prefixo/ag√™ncia)...');
      
      const result = await Tesseract.recognize(
        imageFile,
        'por', // Portugu√™s
        {
          logger: (m) => {
            if (m.status === 'recognizing text') {
              const progress = Math.round(m.progress * 100);
              progressFill.style.width = progress + '%';
              ocrPercent.textContent = progress + '%';
              ocrStatus.textContent = `Reconhecendo texto... ${progress}%`;
            }
          }
        }
      );
      
      ocrProgress.classList.remove('active');
      
      const extractedText = result.data.text;
      console.log('‚úÖ OCR conclu√≠do. Texto extra√≠do:', extractedText);
      
      if (!extractedText || extractedText.trim().length < 10) {
        throw new Error('Texto insuficiente extra√≠do da imagem');
      }
      
      return extractedText;
      
    } catch (error) {
      ocrProgress.classList.remove('active');
      console.error('‚ùå Erro no OCR:', error);
      throw error;
    }
  }

  /* ========================================
     ANEXO DE IMAGEM GLOBAL (CAMPO 2)
  ======================================== */
  const attachArea = el('#attachArea');
  const attachPreview = el('#attachPreview');
  const attachImg = el('#attachImg');
  const attachInfo = el('#attachInfo');
  const fileInput = el('#fileInput');
  const removeAttachBtn = el('#removeAttach');
  
  function processImageFile(file) {
    if (!file || !file.type.startsWith('image/')) {
      alert('‚ùå Por favor, selecione um arquivo de imagem v√°lido.');
      return;
    }
    
    const reader = new FileReader();
    
    reader.onload = (e) => {
      const dataUrl = e.target.result;
      
      // Criar blob da imagem
      fetch(dataUrl)
        .then(res => res.blob())
        .then(blob => {
          globalAttachment = {
            blob,
            dataUrl,
            filename: file.name,
            size: file.size
          };
          
          // Atualizar UI
          attachImg.src = dataUrl;
          attachInfo.textContent = `${file.name} (${formatFileSize(file.size)})`;
          attachPreview.classList.add('active');
          
          log(`Imagem anexada: ${file.name}`);
          updatePreview();
        })
        .catch(err => {
          console.error('Erro ao processar imagem:', err);
          alert('‚ùå Erro ao processar a imagem.');
        });
    };
    
    reader.readAsDataURL(file);
  }
  
  // Drag and drop no campo de anexo
  attachArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    attachArea.classList.add('dragover');
  });
  
  attachArea.addEventListener('dragleave', () => {
    attachArea.classList.remove('dragover');
  });
  
  attachArea.addEventListener('drop', (e) => {
    e.preventDefault();
    attachArea.classList.remove('dragover');
    
    const files = e.dataTransfer.files;
    if (files.length > 0) {
      processImageFile(files[0]);
    }
  });
  
  // Paste no campo de anexo
  attachArea.addEventListener('paste', (e) => {
    const items = (e.clipboardData || e.originalEvent.clipboardData).items;
    
    for (const item of items) {
      if (item.type.indexOf('image') !== -1) {
        e.preventDefault();
        const imageFile = item.getAsFile();
        processImageFile(imageFile);
        return;
      }
    }
  });
  
  // Click para selecionar arquivo
  fileInput.addEventListener('change', (e) => {
    if (e.target.files.length > 0) {
      processImageFile(e.target.files[0]);
    }
  });
  
  // Remover anexo
  removeAttachBtn.addEventListener('click', () => {
    globalAttachment = null;
    attachPreview.classList.remove('active');
    attachImg.src = '';
    attachInfo.textContent = '';
    fileInput.value = '';
    log('Anexo removido');
    updatePreview();
  });

  /* ========================================
     SAUDA√á√ÉO PERSONALIZADA
  ======================================== */
  const DEFAULT_GREETING = 'Ol√° {nome}, tudo bem?';
  const greetingInput = el('#greetingInput');
  const saveGreetingBtn = el('#saveGreeting');

  function loadGreeting() {
    try {
      const saved = localStorage.getItem('customGreeting');
      greetingInput.value = saved && saved.trim() ? saved : DEFAULT_GREETING;
    } catch (e) {
      console.warn('Erro ao carregar sauda√ß√£o salva:', e);
      greetingInput.value = DEFAULT_GREETING;
    }
  }

  function saveGreeting() {
    try {
      const value = (greetingInput.value || '').trim() || DEFAULT_GREETING;
      localStorage.setItem('customGreeting', value);
      log('Sauda√ß√£o salva com sucesso!');
      updatePreview();
    } catch (e) {
      logErr('N√£o foi poss√≠vel salvar a sauda√ß√£o', e.message);
    }
  }

  function makeGreeting(contact) {
    const template = greetingInput.value || DEFAULT_GREETING;
    const nome = firstName(contact?.nome);
    return template
      .replace(/\{nome\}/gi, nome)
      .replace(/<\s*primeiro\s+nome\s*>/gi, nome);
  }

  loadGreeting();
  saveGreetingBtn.addEventListener('click', saveGreeting);
  greetingInput.addEventListener('input', debounce(() => updatePreview(), 150));

  /* ========================================
     DETEC√á√ÉO DE DELIMITADORES
  ======================================== */
  function detectDelimiter(text) {
    const sample = text.split(/\r?\n/).slice(0, 10).join('\n');
    
    const countChar = (ch) => (sample.match(new RegExp('\\' + ch, 'g')) || []).length;
    
    const scores = [
      { delimiter: '\t', count: countChar('\t') },
      { delimiter: ';', count: countChar(';') },
      { delimiter: ',', count: countChar(',') }
    ].sort((a, b) => b.count - a.count);
    
    if (scores[0].count > 0) return scores[0].delimiter;
    
    // Detectar m√∫ltiplos espa√ßos
    return / {2,}/.test(sample) ? ' +' : '\t';
  }

  function splitFlexible(line, separator) {
    if (separator === ' +') {
      return line.trim().split(/ {2,}/);
    }
    return line.split(separator);
  }

  /* ========================================
     PROCESSAMENTO DE PLANILHA (CAMPO 3)
  ======================================== */
  const sheetPaste = el('#sheetPaste');
  const sheetPreview = el('#sheetPreview');
  const sheetTitle = el('#sheetTitle');
  const headerRowInput = el('#headerRow');

  function tableFromArrayOfArrays(aoa) {
    if (!aoa || !aoa.length) return document.createElement('table');
    
    const table = document.createElement('table');
    const thead = document.createElement('thead');
    const tbody = document.createElement('tbody');
    
    // Cabe√ßalho
    const headerRow = document.createElement('tr');
    aoa[0].forEach(cell => {
      const th = document.createElement('th');
      th.textContent = String(cell || '');
      headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    
    // Corpo
    aoa.slice(1).forEach(row => {
      const tr = document.createElement('tr');
      aoa[0].forEach((_, colIndex) => {
        const td = document.createElement('td');
        td.textContent = String(row[colIndex] ?? '');
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    });
    
    table.appendChild(thead);
    table.appendChild(tbody);
    return table;
  }

  function extractFromEditable(container) {
    // Verifica se h√° uma tabela HTML
    const table = container.querySelector('table');
    if (table) {
      const rows = Array.from(table.rows);
      const aoa = rows.map(tr => 
        Array.from(tr.cells).map(td => (td.innerText || '').trim())
      );
      
      if (!aoa.length) return { headers: [], rowsAoA: [] };
      return { headers: aoa[0], rowsAoA: aoa.slice(1) };
    }
    
    // Caso contr√°rio, processa como texto
    const text = container.innerText || '';
    const lines = text.split(/\r?\n/).filter(l => l.trim().length);
    
    if (!lines.length) return { headers: [], rowsAoA: [] };
    
    const separator = detectDelimiter(text);
    const aoa = lines.map(line => 
      splitFlexible(line, separator).map(x => String(x ?? '').trim())
    );
    
    // Normalizar colunas
    const maxCols = aoa.reduce((max, row) => Math.max(max, row.length), 0);
    aoa.forEach(row => {
      while (row.length < maxCols) row.push('');
    });
    
    return { headers: aoa[0], rowsAoA: aoa.slice(1) };
  }

  function refreshPreviewFromEditable() {
    try {
      // Se h√° imagem colada, n√£o processar preview de texto
      if (pastedSheetImage) {
        sheetPreview.style.display = 'none';
        return;
      }
      
      const { headers: h, rowsAoA } = extractFromEditable(sheetPaste);
      
      if (!h.length || !rowsAoA.length) {
        sheetPreview.style.display = 'none';
        sheetPreview.innerHTML = '';
        return;
      }
      
      const fullArray = [h, ...rowsAoA];
      sheetPreview.innerHTML = '';
      sheetPreview.appendChild(tableFromArrayOfArrays(fullArray));
      sheetPreview.style.display = 'block';
    } catch (e) {
      console.error('Erro ao atualizar pr√©via:', e);
    }
  }

  // Interceptar PASTE para detectar imagens NO CAMPO PLANILHA
  sheetPaste.addEventListener('paste', async (e) => {
    const items = (e.clipboardData || e.originalEvent.clipboardData).items;
    
    for (const item of items) {
      if (item.type.indexOf('image') !== -1) {
        e.preventDefault();
        
        const imageFile = item.getAsFile();
        console.log('üì∑ Imagem detectada no campo planilha, iniciando OCR...');
        
        // Mostrar a imagem colada
        const reader = new FileReader();
        reader.onload = (evt) => {
          sheetPaste.innerHTML = `<img src="${evt.target.result}" alt="Imagem colada" />`;
          pastedSheetImage = evt.target.result;
        };
        reader.readAsDataURL(imageFile);
        
        try {
          showOk('Processando imagem com OCR (foco em prefixo/ag√™ncia)... Aguarde.');
          
          const extractedText = await performOCR(imageFile);
          
          // N√£o substituir a imagem, apenas guardar o texto processado
          console.log('üìù Texto do OCR salvo (imagem permanece vis√≠vel)');
          
          // Processar o texto extra√≠do
          const lines = extractedText.split(/\r?\n/).filter(l => l.trim().length);
          
          if (!lines.length) {
            throw new Error('Nenhuma linha v√°lida extra√≠da');
          }
          
          const separator = detectDelimiter(extractedText);
          const aoa = lines.map(line => 
            splitFlexible(line, separator).map(x => String(x ?? '').trim())
          );
          
          // Normalizar colunas
          const maxCols = aoa.reduce((max, row) => Math.max(max, row.length), 0);
          aoa.forEach(row => {
            while (row.length < maxCols) row.push('');
          });
          
          const headersRow = aoa[0] || [];
          const dataRows = aoa.slice(1);
          
          headers = headersRow.map(x => String(x || '').trim());
          
          rowsAll = dataRows
            .filter(row => row.some(value => String(value).trim() !== ''))
            .map(row => {
              const obj = {};
              headers.forEach((header, idx) => {
                obj[header] = (row[idx] ?? '').toString().trim();
              });
              return obj;
            });
          
          console.log('üìä Dados extra√≠dos do OCR:', { headers, rowsCount: rowsAll.length });
          
          imageCacheByContact.clear();
          recountAndAutoselect();
          
          const statsText = `OCR: ${rowsAll.length} linha(s) ‚Ä¢ ${headers.length} coluna(s)`;
          el('#attachStats').textContent = statsText;
          el('#attachStats').className = 'badge success';
          
          el('#clearAttach').disabled = rowsAll.length === 0;
          el('#downloadZip').disabled = rowsAll.length === 0;
          
          showOk('‚úÖ OCR conclu√≠do! Dados extra√≠dos e associados automaticamente.');
          log('OCR conclu√≠do - imagem mantida, dados processados');
          
        } catch (error) {
          showError('Falha no OCR', error.message || 'N√£o foi poss√≠vel extrair texto da imagem');
          logErr('Erro no OCR', error.message);
          pastedSheetImage = null;
          sheetPaste.innerHTML = '';
        }
        
        return;
      }
    }
    
    // Se n√£o for imagem, processar normalmente
    pastedSheetImage = null;
    setTimeout(refreshPreviewFromEditable, 50);
  });
  
  sheetPaste.addEventListener('keyup', debounce(refreshPreviewFromEditable, 300));

  function showError(msg, detail = '') {
    const box = el('#errorBox');
    if (!box) return;
    const fullMsg = detail ? `${msg}<br><small>${detail}</small>` : msg;
    box.innerHTML = `<div class="err"><strong>‚ùå Erro:</strong> ${fullMsg}</div>`;
  }

  function showOk(msg) {
    const box = el('#errorBox');
    if (!box) return;
    box.innerHTML = `<div class="ok">‚úÖ ${msg}</div>`;
  }

  // Bot√£o "Usar dados colados"
  el('#usePasted').addEventListener('click', () => {
    try {
      // Se j√° processou OCR, n√£o precisa reprocessar
      if (pastedSheetImage && headers.length && rowsAll.length) {
        showOk('Dados j√° processados pelo OCR!');
        log('Usando dados j√° processados pelo OCR');
        return;
      }
      
      const { headers: h0, rowsAoA } = extractFromEditable(sheetPaste);
      
      if (!rowsAoA.length || !h0.length) {
        showError('Nada para processar. Cole a planilha e tente novamente.');
        return;
      }
      
      const hdrRowValue = headerRowInput.value.trim();
      const fullArray = [h0, ...rowsAoA];
      let headerIndex = 0;
      
      if (hdrRowValue) {
        const num = parseInt(hdrRowValue, 10);
        if (Number.isInteger(num) && num >= 1 && num <= fullArray.length) {
          headerIndex = num - 1;
        }
      }
      
      const headersRow = fullArray[headerIndex] || fullArray[0];
      headers = headersRow.map(x => String(x || '').trim());
      
      const dataArray = fullArray
        .slice(headerIndex + 1)
        .filter(row => row.some(value => String(value).trim() !== ''));
      
      rowsAll = dataArray.map(row => {
        const obj = {};
        headers.forEach((header, idx) => {
          obj[header] = (row[idx] ?? '').toString().trim();
        });
        return obj;
      });
      
      console.log('üìä Planilha processada:', { headers, rowsCount: rowsAll.length });
      
      imageCacheByContact.clear();
      recountAndAutoselect();
      
      const statsText = `Planilha: ${rowsAll.length} linha(s) ‚Ä¢ ${headers.length} coluna(s)`;
      el('#attachStats').textContent = statsText;
      el('#attachStats').className = 'badge success';
      
      el('#clearAttach').disabled = rowsAll.length === 0;
      el('#downloadZip').disabled = rowsAll.length === 0;
      
      showOk('Dados aplicados com sucesso!');
      log('Planilha aplicada (Campo 3)');
      refreshPreviewFromEditable();
      
    } catch (err) {
      console.error('Erro ao processar planilha:', err);
      showError('Falha ao processar a planilha colada', err?.message || String(err));
      logErr('Erro ao processar planilha', err?.message || String(err));
    }
  });

  // Bot√£o "Limpar dados"
  el('#clearAttach').addEventListener('click', () => {
    headers = [];
    rowsAll = [];
    groupedRowsByContact.clear();
    imageCacheByContact.clear();
    pastedSheetImage = null;
    
    contacts.forEach(c => c.attachCount = 0);
    
    el('#attachStats').textContent = 'Sem dados';
    el('#attachStats').className = 'badge warning';
    el('#errorBox').innerHTML = '';
    el('#clearAttach').disabled = true;
    el('#downloadZip').disabled = true;
    
    if (sheetPreview) {
      sheetPreview.style.display = 'none';
      sheetPreview.innerHTML = '';
    }
    
    sheetPaste.innerHTML = '';
    renderContacts();
    updatePreview();
    log('Planilha limpa');
  });

  /* ========================================
     ASSOCIA√á√ÉO LINHAS x CONTATOS
     FOCO: prefixo e ag√™ncia
  ======================================== */
  function recountAndAutoselect() {
    groupedRowsByContact.clear();
    
    console.log('üîç Iniciando associa√ß√£o (FOCO: prefixo/ag√™ncia)...');
    console.log('üìã Cabe√ßalhos da planilha:', headers);
    console.log('üë• Total de contatos:', contacts.length);
    console.log('üìä Total de linhas:', rowsAll.length);
    
    // Identificar colunas relevantes - PRIORIDADE: prefixo e ag√™ncia
    const prefixCols = headers.filter(h => {
      const k = normalizeKey(h);
      return k.includes('prefix') || k.includes('pref') || k.includes('ag√™n') || k.includes('agen');
    });
    
    const depCols = headers.filter(h => {
      const k = normalizeKey(h);
      return k === 'dependencia' || k === 'depend√™ncia' || k.includes('depend');
    });
    
    const nameCols = headers.filter(h => {
      const k = normalizeKey(h);
      return k === 'nome' || k.includes('nome');
    });
    
    console.log('üè∑Ô∏è Colunas reconhecidas (prioridade: prefixo/ag√™ncia):', {
      prefixo: prefixCols,
      dependencia: depCols,
      nome: nameCols
    });
    
    // Valida√ß√£o cr√≠tica
    if (!prefixCols.length && !nameCols.length && !depCols.length) {
      const msg = 'Nenhuma coluna reconhecida na planilha. Use: "prefixo/pref/ag√™ncia", "nome" ou "depend√™ncia"';
      logErr(msg);
      showError(msg, 'Verifique os nomes das colunas da planilha.');
      return;
    }
    
    let totalMatches = 0;
    
    // Associar cada contato - PRIORIDADE: prefixo/ag√™ncia
    contacts.forEach((contact, idx) => {
      const matchedRows = [];
      const prefixo = String(contact.prefixo || '').trim();
      const nomeContato = String(contact.nome || '').trim();
      
      for (const row of rowsAll) {
        let matched = false;
        
        // PRIORIDADE 1: Tentar por prefixo/ag√™ncia
        if (prefixCols.length && prefixo) {
          for (const header of prefixCols) {
            const cellValue = String(row[header] ?? '').trim();
            if (equalsLoose(cellValue, prefixo)) {
              matched = true;
              console.log(`‚úÖ Match por prefixo/ag√™ncia: ${contact.nome} (${prefixo}) ‚Üî ${header}="${cellValue}"`);
              break;
            }
          }
        }
        
        // PRIORIDADE 2: Tentar por depend√™ncia (s√≥ se n√£o encontrou por prefixo)
        if (!matched && depCols.length && nomeContato) {
          for (const header of depCols) {
            const cellValue = String(row[header] ?? '').trim();
            if (equalsLoose(cellValue, nomeContato)) {
              matched = true;
              console.log(`‚úÖ Match por depend√™ncia: ${nomeContato} ‚Üî ${header}="${cellValue}"`);
              break;
            }
          }
        }
        
        // PRIORIDADE 3: Tentar por nome (√∫ltima op√ß√£o)
        if (!matched && nameCols.length && nomeContato) {
          for (const header of nameCols) {
            const cellValue = String(row[header] ?? '').trim();
            if (equalsLoose(cellValue, nomeContato)) {
              matched = true;
              console.log(`‚úÖ Match por nome: ${nomeContato} ‚Üî ${header}="${cellValue}"`);
              break;
            }
          }
        }
        
        if (matched) {
          matchedRows.push(row);
          totalMatches++;
        }
      }
      
      groupedRowsByContact.set(idx, matchedRows);
      contact.attachCount = matchedRows.length;
      
      // Auto-selecionar contatos com linhas
      if (matchedRows.length > 0) {
        contact.selected = true;
      }
      
      if (matchedRows.length > 0) {
        console.log(`üìå ${contact.nome}: ${matchedRows.length} linha(s) associada(s)`);
      }
    });
    
    console.log(`üìä RESUMO: ${totalMatches} linha(s) associada(s) no total`);
    log(`Associa√ß√£o conclu√≠da (foco prefixo/ag√™ncia): ${totalMatches} linha(s) vinculada(s)`);
    
    renderContacts();
    updatePreview();
  }

  /* ========================================
     PROCESSAMENTO DE CONTATOS (CAMPO 1)
  ======================================== */
  function guessColumns(headersRow, dataRows) {
    const normalized = headersRow.map(h => normalizeKey(stripAccents(h)));
    
    // Procurar "nome" exato primeiro
    let iNome = normalized.findIndex(h => h === 'nome');
    if (iNome < 0) {
      iNome = normalized.findIndex(h => h.includes('nome'));
    }
    
    // Prefixo
    let iPrefixo = normalized.findIndex(h => 
      /^(prefixo|pref|prefix|agencia|ag√™ncia|agen)$/.test(h)
    );
    
    // Email
    let iEmail = normalized.findIndex(h => 
      /^(email|e-mail|mail|contato|contact)$/.test(h)
    );
    
    // Se n√£o encontrou email por nome, procurar por padr√£o @
    if (iEmail < 0 && dataRows.length > 0) {
      for (let colIndex = 0; colIndex < (dataRows[0]?.length || 0); colIndex++) {
        if (dataRows.some(row => /@/.test(String(row[colIndex] || '')))) {
          iEmail = colIndex;
          break;
        }
      }
    }
    
    return { iPrefixo, iNome, iEmail };
  }

  function parseContacts(rawText) {
    rawText = (rawText || '').trim();
    if (!rawText) return [];
    
    const separator = detectDelimiter(rawText);
    const lines = rawText.split(/\r?\n/).filter(l => l.trim().length);
    
    if (lines.length === 0) return [];
    
    const arrayOfArrays = lines.map(line => 
      splitFlexible(line, separator).map(x => String(x ?? '').trim())
    );
    
    const maxCols = arrayOfArrays.reduce((max, row) => Math.max(max, row.length), 0);
    arrayOfArrays.forEach(row => {
      while (row.length < maxCols) row.push('');
    });
    
    let headersRow = arrayOfArrays[0];
    let dataRows = arrayOfArrays.slice(1);
    let { iPrefixo, iNome, iEmail } = guessColumns(headersRow, dataRows);
    
    // Se n√£o encontrou colunas, tentar sem cabe√ßalho
    if (iPrefixo < 0 || iNome < 0 || iEmail < 0) {
      console.warn('‚ö†Ô∏è Colunas n√£o identificadas no cabe√ßalho, tentando sem cabe√ßalho...');
      headersRow = Array.from({ length: maxCols }, (_, i) => `col${i + 1}`);
      dataRows = arrayOfArrays;
      const guess = guessColumns(headersRow, dataRows);
      iPrefixo = guess.iPrefixo;
      iNome = guess.iNome;
      iEmail = guess.iEmail;
    }
    
    // Valida√ß√£o final
    if (iPrefixo < 0 || iNome < 0 || iEmail < 0) {
      alert('‚ùå N√£o foi poss√≠vel identificar as colunas de prefixo, nome e email.\n\nVerifique se a primeira linha cont√©m cabe√ßalhos ou se os dados est√£o formatados corretamente.');
      console.error('√çndices encontrados:', { iPrefixo, iNome, iEmail });
      return [];
    }
    
    console.log('‚úÖ Colunas identificadas:', { iPrefixo, iNome, iEmail });
    
    const parsedContacts = [];
    for (const row of dataRows) {
      const prefixo = String(row[iPrefixo] || '').trim();
      const nome = String(row[iNome] || '').trim();
      const email = String(row[iEmail] || '').trim();
      
      // Pular linhas vazias
      if (!nome && !email) continue;
      
      parsedContacts.push({
        prefixo,
        nome,
        email,
        selected: false,
        attachCount: 0
      });
    }
    
    console.log(`‚úÖ ${parsedContacts.length} contato(s) processado(s)`);
    return parsedContacts;
  }

  function renderContacts() {
    const tbody = el('#contactsTable tbody');
    if (!tbody) return;
    
    tbody.innerHTML = '';
    filteredContactsIdx = [];
    
    const searchQuery = normalizeKey(el('#searchBox').value);
    
    contacts.forEach((contact, index) => {
      const searchableText = normalizeKey(
        `${contact.prefixo} ${contact.nome} ${contact.email}`
      );
      
      // Filtrar por busca
      if (searchQuery && !searchableText.includes(searchQuery)) return;
      
      filteredContactsIdx.push(index);
      
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><input type="checkbox" data-idx="${index}" ${contact.selected ? 'checked' : ''}></td>
        <td>${contact.prefixo || '‚Äî'}</td>
        <td><strong>${contact.nome || '‚Äî'}</strong></td>
        <td>${contact.email || '‚Äî'}</td>
        <td><span class="badge ${contact.attachCount > 0 ? 'success' : ''}">${contact.attachCount || 0}</span></td>
      `;
      tbody.appendChild(tr);
    });
    
    // Atualizar estat√≠sticas
    const total = contacts.length;
    const shown = filteredContactsIdx.length;
    const selected = contacts.filter(c => c.selected).length;
    
    el('#contactStats').textContent = `${total} contato${total !== 1 ? 's' : ''} ‚Ä¢ ${shown} exibido${shown !== 1 ? 's' : ''} ‚Ä¢ ${selected} selecionado${selected !== 1 ? 's' : ''}`;
    
    // Atualizar "Selecionar todos"
    const allSelected = filteredContactsIdx.length > 0 && 
                        filteredContactsIdx.every(i => contacts[i]?.selected);
    const someSelected = filteredContactsIdx.some(i => contacts[i]?.selected);
    
    const selectAll = el('#selectAll');
    if (selectAll) {
      selectAll.checked = allSelected;
      selectAll.indeterminate = !allSelected && someSelected;
    }
  }

  function saveContactsIfEnabled() {
    try {
      if (el('#keepContacts').checked) {
        localStorage.setItem('savedContactsRaw', el('#contactsInput').value || '');
        localStorage.setItem('keepContacts', '1');
        console.log('üíæ Contatos salvos localmente');
      } else {
        localStorage.removeItem('savedContactsRaw');
        localStorage.setItem('keepContacts', '0');
        console.log('üóëÔ∏è Contatos removidos do armazenamento');
      }
    } catch (e) {
      console.warn('‚ö†Ô∏è N√£o foi poss√≠vel salvar/remover contatos:', e);
    }
  }

  function loadSavedContactsOnStart() {
    try {
      const keepEnabled = localStorage.getItem('keepContacts') === '1';
      el('#keepContacts').checked = keepEnabled;
      
      if (keepEnabled) {
        const saved = localStorage.getItem('savedContactsRaw') || '';
        if (saved) {
          el('#contactsInput').value = saved;
          const parsed = parseContacts(saved);
          if (parsed.length) {
            contacts = parsed;
            renderContacts();
            log('Contatos carregados do armazenamento local');
          }
        }
      }
    } catch (e) {
      console.warn('‚ö†Ô∏è Erro ao carregar contatos salvos:', e);
    }
  }

  loadSavedContactsOnStart();

  // Event listeners do Campo 1
  el('#keepContacts').addEventListener('change', saveContactsIfEnabled);

  el('#loadContacts').addEventListener('click', () => {
    const rawText = el('#contactsInput').value;
    const parsed = parseContacts(rawText);
    
    if (!parsed.length) {
      log('Nenhum contato v√°lido encontrado', 'warn');
      renderContacts();
      return;
    }
    
    contacts = parsed;
    recountAndAutoselect();
    renderContacts();
    saveContactsIfEnabled();
    log(`${parsed.length} contato(s) carregado(s) com sucesso!`);
  });

  el('#clearContacts').addEventListener('click', () => {
    contacts = [];
    el('#contactsInput').value = '';
    renderContacts();
    el('#output').innerHTML = '';
    saveContactsIfEnabled();
    log('Contatos limpos');
  });

  el('#contactsTable').addEventListener('change', e => {
    if (e.target.matches('input[type="checkbox"][data-idx]')) {
      const idx = Number(e.target.getAttribute('data-idx'));
      if (!Number.isNaN(idx) && contacts[idx]) {
        contacts[idx].selected = e.target.checked;
      }
      renderContacts();
      updatePreview();
    }
  });

  el('#selectAll').addEventListener('change', e => {
    const shouldCheck = e.target.checked;
    filteredContactsIdx.forEach(idx => {
      if (contacts[idx]) {
        contacts[idx].selected = shouldCheck;
      }
    });
    renderContacts();
    updatePreview();
  });

  el('#searchBox').addEventListener('input', debounce(() => {
    renderContacts();
    updatePreview();
  }, 200));

  /* ========================================
     EDITOR DE MENSAGENS (CAMPO 2)
  ======================================== */
  const messageBody = el('#messageBody');

  // Bot√µes de formata√ß√£o
  document.querySelectorAll('.rte-btn[data-cmd]').forEach(btn => {
    btn.addEventListener('click', () => {
      const command = btn.getAttribute('data-cmd');
      document.execCommand(command, false, null);
      messageBody.focus();
      
      // Visual feedback
      btn.classList.add('active');
      setTimeout(() => btn.classList.remove('active'), 200);
      
      updatePreviewDebounced();
    });
  });

  // Prevenir colagem de HTML formatado
  messageBody.addEventListener('paste', e => {
    e.preventDefault();
    const text = (e.clipboardData || window.clipboardData).getData('text/plain');
    document.execCommand('insertText', false, text);
  });

  // Sanitizar HTML do editor
  function sanitizeEditorHTML(html) {
    const allowedTags = new Set(['B', 'STRONG', 'I', 'EM', 'U', 'BR', 'P']);
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;
    
    function walkAndClean(node) {
      const children = Array.from(node.childNodes);
      for (const child of children) {
        if (child.nodeType === 1) { // Element node
          if (!allowedTags.has(child.tagName)) {
            // Remover tag mas manter conte√∫do
            while (child.firstChild) {
              node.insertBefore(child.firstChild, child);
            }
            node.removeChild(child);
          } else {
            // Remover todos os atributos
            [...child.attributes].forEach(attr => {
              child.removeAttribute(attr.name);
            });
            walkAndClean(child);
          }
        }
      }
    }
    
    walkAndClean(tempDiv);
    
    // Converter DIVs em par√°grafos
    tempDiv.querySelectorAll('div').forEach(div => {
      const p = document.createElement('p');
      p.innerHTML = div.innerHTML;
      div.replaceWith(p);
    });
    
    return tempDiv.innerHTML
      .replace(/&nbsp;/g, ' ')
      .replace(/<p>\s*<\/p>/g, '');
  }

  function getEditorHTMLClean() {
    const raw = messageBody.innerHTML || '';
    const clean = sanitizeEditorHTML(raw);
    return clean.trim();
  }

  const updatePreviewDebounced = debounce(() => updatePreview(), 150);

  messageBody.addEventListener('input', updatePreviewDebounced);
  messageBody.addEventListener('keyup', updatePreviewDebounced);

  /* ========================================
     GERA√á√ÉO DE PRINTS (CANVAS)
  ======================================== */
  async function buildPrintForContact(contactIndex) {
    const titulo = sheetTitle.value.trim() || 'Planilha';
    const rows = groupedRowsByContact.get(contactIndex) || [];
    
    if (!headers.length || !rows.length) {
      console.warn(`‚ö†Ô∏è Sem dados para gerar print do contato ${contactIndex}`);
      return null;
    }
    
    console.log(`üé® Gerando print para contato ${contactIndex}...`);
    
    // Configura√ß√µes visuais
    const padX = 16;
    const padY = 12;
    const gapTitle = 12;
    const rowHeight = 30;
    const headerHeight = 32;
    const borderWidth = 1;
    
    const fontRegular = '13px Segoe UI, Roboto, Arial, sans-serif';
    const fontBold = '600 13px Segoe UI, Roboto, Arial, sans-serif';
    const fontTitle = '600 17px Segoe UI, Roboto, Arial, sans-serif';
    
    // Canvas tempor√°rio para medi√ß√µes
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.font = fontRegular;
    
    // Calcular larguras das colunas
    const columnWidths = headers.map(header => {
      let maxWidth = tempCtx.measureText(header).width + 24;
      
      rows.forEach(row => {
        const cellText = String(row[header] ?? '');
        const textWidth = tempCtx.measureText(cellText).width + 24;
        maxWidth = Math.max(maxWidth, textWidth);
      });
      
      // Limitar largura das colunas
      return Math.min(Math.max(90, Math.ceil(maxWidth)), 380);
    });
    
    const tableWidth = columnWidths.reduce((sum, w) => sum + w, 0) + 
                       borderWidth * (headers.length + 1);
    const tableHeight = headerHeight + rows.length * rowHeight + 
                        borderWidth * (rows.length + 1);
    const titleHeight = 26;
    
    const totalWidth = Math.ceil(padX * 2 + tableWidth);
    const totalHeight = Math.ceil(padY * 2 + titleHeight + gapTitle + tableHeight);
    
    // Canvas principal
    const canvas = document.createElement('canvas');
    canvas.width = totalWidth;
    canvas.height = totalHeight;
    const ctx = canvas.getContext('2d');
    
    // Fundo branco
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, totalWidth, totalHeight);
    
    // T√≠tulo
    ctx.font = fontTitle;
    ctx.fillStyle = '#0f172a';
    ctx.fillText(titulo, padX, padY + 20);
    
    // Posi√ß√£o inicial da tabela
    let x = padX;
    let y = padY + titleHeight + gapTitle;
    
    // Fundo do cabe√ßalho
    ctx.fillStyle = '#f8fafc';
    ctx.fillRect(x, y, tableWidth, headerHeight);
    
    // Bordas
    ctx.strokeStyle = '#e5e7eb';
    ctx.lineWidth = borderWidth;
    
    // Linhas horizontais
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + tableWidth, y);
    ctx.moveTo(x, y + headerHeight);
    ctx.lineTo(x + tableWidth, y + headerHeight);
    
    for (let i = 1; i <= rows.length; i++) {
      const lineY = y + headerHeight + i * rowHeight;
      ctx.moveTo(x, lineY);
      ctx.lineTo(x + tableWidth, lineY);
    }
    ctx.stroke();
    
    // Linhas verticais
    ctx.beginPath();
    let currentX = x;
    for (let i = 0; i <= headers.length; i++) {
      ctx.moveTo(currentX, y);
      ctx.lineTo(currentX, y + headerHeight + rows.length * rowHeight);
      currentX += columnWidths[i] || 0;
    }
    ctx.stroke();
    
    // Renderizar cabe√ßalho
    ctx.font = fontBold;
    ctx.fillStyle = '#111827';
    let headerX = x + borderWidth + 10;
    
    headers.forEach((header, colIndex) => {
      ctx.fillText(String(header), headerX, y + 22);
      headerX += columnWidths[colIndex];
    });
    
    // Renderizar linhas de dados
    ctx.font = fontRegular;
    ctx.fillStyle = '#111827';
    let rowY = y + headerHeight + 22;
    
    rows.forEach(row => {
      let cellX = x + borderWidth + 10;
      
      headers.forEach((header, colIndex) => {
        const cellValue = String(row[header] ?? '');
        ctx.fillText(cellValue, cellX, rowY);
        cellX += columnWidths[colIndex];
      });
      
      rowY += rowHeight;
    });
    
    // Redimensionar para melhor qualidade
    const targetWidth = Math.min(560, totalWidth);
    const scale = targetWidth / totalWidth;
    const targetHeight = Math.round(totalHeight * scale);
    
    // UPSCALE: 2x resolu√ß√£o (100% mais pixels)
    const UPSCALE_FACTOR = 2;
    const finalCanvas = document.createElement('canvas');
    finalCanvas.width = Math.round(targetWidth * UPSCALE_FACTOR);
    finalCanvas.height = Math.round(targetHeight * UPSCALE_FACTOR);
    
    const finalCtx = finalCanvas.getContext('2d');
    finalCtx.imageSmoothingEnabled = true;
    finalCtx.imageSmoothingQuality = 'high';
    finalCtx.drawImage(canvas, 0, 0, finalCanvas.width, finalCanvas.height);
    
    return new Promise(resolve => {
      finalCanvas.toBlob(blob => {
        if (!blob) {
          console.error('‚ùå Falha ao gerar blob da imagem');
          return resolve(null);
        }
        
        const dataUrl = finalCanvas.toDataURL('image/png', 0.95);
        console.log(`‚úÖ Print gerado: ${Math.round(blob.size / 1024)}KB`);
        resolve({ blob, dataUrl });
      }, 'image/png', 0.95);
    });
  }

  /* ========================================
     CONSTRU√á√ÉO DE MENSAGENS
  ======================================== */
  function buildMessageHTML(contact, imageDataUrl, bodyHTMLClean) {
    const greeting = makeGreeting(contact);
    const introHTML = `<p>${greeting}</p>`;
    const contentHTML = bodyHTMLClean ? bodyHTMLClean : '';
    
    // Adicionar print da planilha (se houver)
    const sheetImageHTML = imageDataUrl 
      ? `<div class="separator"></div><div class="imgwrap"><img src="${imageDataUrl}" alt="print da planilha"></div>` 
      : '';
    
    // Adicionar anexo global (se houver)
    const attachmentHTML = globalAttachment 
      ? `<div class="separator"></div><div class="imgwrap"><img src="${globalAttachment.dataUrl}" alt="${globalAttachment.filename}"></div>` 
      : '';
    
    return `<div class="richmsg">${introHTML}${contentHTML}${sheetImageHTML}${attachmentHTML}</div>`;
  }

  function htmlToPlainText(html) {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;
    return (tempDiv.textContent || tempDiv.innerText || '').trim();
  }

  function buildMessagePlainText(contact, bodyHTMLClean) {
    const greeting = makeGreeting(contact);
    const bodyText = htmlToPlainText(bodyHTMLClean || '');
    const bodyPart = bodyText ? `\n\n${bodyText}` : '';
    return `${greeting}${bodyPart}`;
  }

  /* ========================================
     PREVIEW (CAMPO 2)
  ======================================== */
  async function updatePreview() {
    const previewBox = el('#previewBox');
    if (!previewBox) return;
    
    const bodyHTMLClean = getEditorHTMLClean();
    
    // Encontrar primeiro contato selecionado
    let contactIndex = contacts.findIndex(c => c.selected);
    if (contactIndex < 0) {
      contactIndex = contacts.length > 0 ? 0 : -1;
    }
    
    if (contactIndex < 0) {
      const previewGreeting = (greetingInput.value || DEFAULT_GREETING)
        .replace(/\{nome\}/gi, 'Fulano');
      
      const attachmentPreviewHTML = globalAttachment 
        ? `<div class="separator"></div><div class="imgwrap"><img src="${globalAttachment.dataUrl}" alt="Anexo" style="max-height:150px"></div>` 
        : '';
      
      previewBox.innerHTML = `
        <div class="richmsg">
          <p>${previewGreeting}</p>
          <p class="muted">[sua mensagem]</p>
        </div>
        <div class="separator"></div>
        <div class="imgwrap">
          <div class="muted">[Imagem do print aparecer√° aqui]</div>
        </div>
        ${attachmentPreviewHTML}
      `;
      return;
    }
    
    // Gerar ou recuperar imagem do cache
    let imageData = imageCacheByContact.get(contactIndex);
    if (!imageData) {
      imageData = await buildPrintForContact(contactIndex);
      if (imageData) {
        imageCacheByContact.set(contactIndex, imageData);
      }
    }
    
    const html = buildMessageHTML(
      contacts[contactIndex], 
      imageData?.dataUrl || '', 
      bodyHTMLClean
    );
    
    previewBox.innerHTML = html;
  }

  /* ========================================
     C√ìPIA PARA √ÅREA DE TRANSFER√äNCIA
  ======================================== */
  async function copyMessage(htmlMsg, textMsg, imageBlob, attachmentBlob) {
    // Tentar Clipboard API moderna (com imagens)
    if (navigator.clipboard && window.ClipboardItem) {
      try {
        const itemData = {
          'text/html': new Blob([htmlMsg], { type: 'text/html' }),
          'text/plain': new Blob([textMsg], { type: 'text/plain' })
        };
        
        // Adicionar imagens se existirem
        if (imageBlob) {
          itemData['image/png'] = imageBlob;
        }
        
        if (attachmentBlob) {
          // Se j√° temos o imageBlob, s√≥ conseguimos adicionar uma imagem
          // Neste caso, priorizamos o anexo global
          if (!imageBlob) {
            itemData['image/png'] = attachmentBlob;
          }
        }
        
        await navigator.clipboard.write([new ClipboardItem(itemData)]);
        console.log('‚úÖ Copiado com Clipboard API (HTML + imagens)');
        return 'html';
      } catch (e) {
        console.warn('‚ö†Ô∏è Clipboard API falhou, tentando fallback:', e);
      }
    }
    
    // Fallback: copiar HTML via execCommand
    const tempDiv = document.createElement('div');
    tempDiv.contentEditable = 'true';
    tempDiv.style.position = 'fixed';
    tempDiv.style.left = '-99999px';
    tempDiv.style.top = '0';
    tempDiv.style.opacity = '0';
    tempDiv.innerHTML = htmlMsg;
    
    document.body.appendChild(tempDiv);
    
    const range = document.createRange();
    range.selectNodeContents(tempDiv);
    
    const selection = window.getSelection();
    selection.removeAllRanges();
    selection.addRange(range);
    
    const success = document.execCommand('copy');
    
    selection.removeAllRanges();
    tempDiv.remove();
    
    if (success) {
      console.log('‚úÖ Copiado com execCommand (HTML sem imagens)');
      return 'html';
    }
    
    // √öltimo recurso: apenas texto
    try {
      await navigator.clipboard.writeText(textMsg);
      console.log('‚úÖ Copiado apenas texto');
      return 'text';
    } catch (e) {
      console.error('‚ùå Falha ao copiar:', e);
      return 'error';
    }
  }

  /* ========================================
     TEAMS DEEP LINKS
  ======================================== */
  function teamsDeepLinkBase(email) {
    return 'https://teams.microsoft.com/l/chat/0/0?users=' + encodeURIComponent(email);
  }

  function teamsDeepLinkWithMessage(email, messageText) {
    const base = teamsDeepLinkBase(email);
    return messageText ? base + '&message=' + encodeURIComponent(messageText) : base;
  }

  function openTeamsChatNoPrefill(email) {
    if (!email) {
      alert('‚ùå Contato sem e-mail.');
      return;
    }
    const url = teamsDeepLinkBase(email);
    window.open(url, '_blank', 'noopener,noreferrer');
    console.log(`üîó Teams aberto: ${email}`);
  }

  function openTeamsChatWithMessage(email, messageText) {
    if (!email) {
      alert('‚ùå Contato sem e-mail.');
      return;
    }
    const url = teamsDeepLinkWithMessage(email, messageText || '');
    window.open(url, '_blank', 'noopener,noreferrer');
    console.log(`üîó Teams aberto com mensagem: ${email}`);
  }

  /* ========================================
     COLAPSAR/EXPANDIR MENSAGENS
  ======================================== */
  function setCollapsed(wrapperElement, shouldCollapse) {
    if (shouldCollapse) {
      wrapperElement.classList.add('collapsed');
      const btn = wrapperElement.querySelector('[data-toggle]');
      if (btn) btn.textContent = 'üëÅÔ∏è Expandir';
    } else {
      wrapperElement.classList.remove('collapsed');
      const btn = wrapperElement.querySelector('[data-toggle]');
      if (btn) btn.textContent = 'üëÅÔ∏è Recolher';
    }
  }

  /* ========================================
     GERAR CARDS DE MENSAGEM (CAMPO 4)
  ======================================== */
  async function buildAndMountCardForContact(contactIndex, bodyHTMLClean) {
    const contact = contacts[contactIndex];
    
    // Garantir que a imagem da planilha existe
    let imageData = imageCacheByContact.get(contactIndex);
    if (!imageData) {
      imageData = await buildPrintForContact(contactIndex);
      if (imageData) {
        imageCacheByContact.set(contactIndex, imageData);
      }
    }
    
    const htmlMsg = buildMessageHTML(contact, imageData?.dataUrl || '', bodyHTMLClean);
    const textMsg = buildMessagePlainText(contact, bodyHTMLClean);
    
    // Criar elemento do card
    const wrapper = document.createElement('div');
    wrapper.className = 'msg';
    wrapper.innerHTML = `
      <div class="msg__head">
        <strong>${titleCaseName(contact.nome)}</strong>
        <span class="badge">${contact.email || 'sem email'}</span>
        <span class="badge">Prefixo: ${contact.prefixo || '‚Äî'}</span>
        <button class="msg__toggle" data-toggle>üëÅÔ∏è Recolher</button>
      </div>
      <div class="msg__body">
        <div class="richmsg" data-htmlmsg></div>
        <div class="toolbar" style="margin-top:12px">
          <button class="btn" data-copy>üìã Copiar mensagem (com imagens)</button>
          <button class="btn ghost" data-copyopen ${contact.email ? '' : 'disabled'}>
            üìã Copiar e abrir chat (sem imagens)
          </button>
          <button class="btn dark" data-openchat ${contact.email ? '' : 'disabled'}>
            üí¨ Abrir chat no Teams
          </button>
        </div>
      </div>
    `;
    
    // Inserir conte√∫do HTML da mensagem
    wrapper.querySelector('[data-htmlmsg]').innerHTML = htmlMsg;
    
    // Adicionar ao output
    el('#output').appendChild(wrapper);
    
    // Event listener: Toggle expandir/recolher
    wrapper.querySelector('[data-toggle]').addEventListener('click', () => {
      setCollapsed(wrapper, !wrapper.classList.contains('collapsed'));
    });
    
    // Event listener: Copiar mensagem COM imagens
    wrapper.querySelector('[data-copy]').addEventListener('click', async () => {
      // Garantir imagem atualizada
      let ensureImg = imageCacheByContact.get(contactIndex);
      if (!ensureImg) {
        ensureImg = await buildPrintForContact(contactIndex);
        if (ensureImg) {
          imageCacheByContact.set(contactIndex, ensureImg);
        }
      }
      
      const mode = await copyMessage(
        buildMessageHTML(contact, ensureImg?.dataUrl || '', bodyHTMLClean),
        buildMessagePlainText(contact, bodyHTMLClean),
        ensureImg?.blob,
        globalAttachment?.blob
      );
      
      const btn = wrapper.querySelector('[data-copy]');
      if (mode === 'html') {
        btn.textContent = '‚úÖ Copiado!';
      } else if (mode === 'text') {
        btn.textContent = '‚úÖ Copiado (texto)';
      } else {
        btn.textContent = '‚ùå Erro ao copiar';
      }
      
      setTimeout(() => {
        btn.textContent = 'üìã Copiar mensagem (com imagens)';
      }, 2000);
      
      setCollapsed(wrapper, true);
    });
    
    // Event listener: Copiar SEM imagens e abrir Teams
    const btnCopyOpen = wrapper.querySelector('[data-copyopen]');
    if (btnCopyOpen) {
      btnCopyOpen.addEventListener('click', async () => {
        await copyMessage(
          buildMessageHTML(contact, '', bodyHTMLClean),
          buildMessagePlainText(contact, bodyHTMLClean),
          null,
          null
        );
        
        openTeamsChatWithMessage(contact.email, buildMessagePlainText(contact, bodyHTMLClean));
        setCollapsed(wrapper, true);
      });
    }
    
    // Event listener: Abrir chat (copia COM imagens, abre sem pr√©-carregar)
    const btnOpenChat = wrapper.querySelector('[data-openchat]');
    if (btnOpenChat) {
      btnOpenChat.addEventListener('click', async () => {
        // Garantir imagem
        let ensureImg = imageCacheByContact.get(contactIndex);
        if (!ensureImg) {
          ensureImg = await buildPrintForContact(contactIndex);
          if (ensureImg) {
            imageCacheByContact.set(contactIndex, ensureImg);
          }
        }
        
        // Copiar com imagens
        await copyMessage(
          buildMessageHTML(contact, ensureImg?.dataUrl || '', bodyHTMLClean),
          buildMessagePlainText(contact, bodyHTMLClean),
          ensureImg?.blob,
          globalAttachment?.blob
        );
        
        // Abrir Teams sem pr√©-carregar mensagem (usu√°rio cola manualmente)
        openTeamsChatNoPrefill(contact.email);
        setCollapsed(wrapper, true);
      });
    }
  }

  /* ========================================
     ORDENA√á√ÉO
  ======================================== */
  function sortSelectedIndices(selectedIndices) {
    const sortMode = el('#sortOrder')?.value || 'original';
    
    if (sortMode === 'nome_az') {
      const indexed = selectedIndices.slice().map(idx => ({
        idx,
        sortKey: stripAccents(firstName(contacts[idx]?.nome || '')).toLowerCase()
      }));
      
      indexed.sort((a, b) => a.sortKey.localeCompare(b.sortKey));
      return indexed.map(item => item.idx);
    }
    
    return selectedIndices;
  }

  /* ========================================
     REGENERAR OUTPUT (CAMPO 4)
  ======================================== */
  async function regenerateOutput() {
    const outputContainer = el('#output');
    outputContainer.innerHTML = '<div class="muted" style="text-align:center">‚è≥ Gerando mensagens...</div>';
    
    const bodyHTMLClean = getEditorHTMLClean();
    
    let selectedIndices = contacts
      .map((contact, idx) => contact.selected ? idx : -1)
      .filter(idx => idx >= 0);
    
    if (!selectedIndices.length) {
      outputContainer.innerHTML = '<div class="muted" style="text-align:center">‚ùå Nenhum contato selecionado.</div>';
      return;
    }
    
    // Ordenar se necess√°rio
    selectedIndices = sortSelectedIndices(selectedIndices);
    
    console.log(`üîÑ Gerando ${selectedIndices.length} mensagem(ns)...`);
    
    // Pr√©-gerar todas as imagens necess√°rias
    for (const idx of selectedIndices) {
      if (!imageCacheByContact.has(idx)) {
        const img = await buildPrintForContact(idx);
        if (img) {
          imageCacheByContact.set(idx, img);
        }
      }
    }
    
    //Limpar output
    outputContainer.innerHTML = '';
    
    // Montar cards
    for (const idx of selectedIndices) {
      await buildAndMountCardForContact(idx, bodyHTMLClean);
    }
    
    log(`${selectedIndices.length} mensagem(ns) gerada(s) com sucesso!`);
  }

  // Event listener: Bot√£o "Gerar mensagens"
  el('#generateMsgs').addEventListener('click', async () => {
    await regenerateOutput();
  });

  // Event listener: Ordena√ß√£o
  el('#sortOrder').addEventListener('change', regenerateOutput);

  /* ========================================
     BOT√ÉO TEAMS NO CAMPO 3 (TESTE)
  ======================================== */
  const zipBtn = el('#downloadZip');
  if (zipBtn) {
    zipBtn.addEventListener('click', async () => {
      const firstSelectedIdx = contacts.findIndex(c => c.selected);
      
      if (firstSelectedIdx < 0) {
        alert('‚ùå Selecione ao menos um contato na lista.');
        return;
      }
      
      const bodyHTMLClean = getEditorHTMLClean();
      
      // Garantir imagem
      let ensureImg = imageCacheByContact.get(firstSelectedIdx);
      if (!ensureImg) {
        ensureImg = await buildPrintForContact(firstSelectedIdx);
        if (ensureImg) {
          imageCacheByContact.set(firstSelectedIdx, ensureImg);
        }
      }
      
      // Copiar mensagem com imagens
      await copyMessage(
        buildMessageHTML(contacts[firstSelectedIdx], ensureImg?.dataUrl || '', bodyHTMLClean),
        buildMessagePlainText(contacts[firstSelectedIdx], bodyHTMLClean),
        ensureImg?.blob,
        globalAttachment?.blob
      );
      
      // Abrir Teams COM mensagem pr√©-carregada (teste)
      openTeamsChatWithMessage(
        contacts[firstSelectedIdx].email,
        buildMessagePlainText(contacts[firstSelectedIdx], bodyHTMLClean)
      );
      
      log('Deep link do Teams aberto (teste) + conte√∫do copiado');
    });
  }

  /* ========================================
     ATUALIZA√á√ÉO GLOBAL
  ======================================== */
  async function doFullRefresh() {
    console.log('üîÑ Iniciando atualiza√ß√£o completa...');
    
    // 1. Recarregar contatos se houver texto
    const rawContacts = el('#contactsInput').value.trim();
    if (rawContacts) {
      const parsed = parseContacts(rawContacts);
      if (parsed.length) {
        contacts = parsed;
        console.log(`‚úÖ ${parsed.length} contato(s) recarregado(s)`);
      }
    }
    
    // 2. Reprocessar planilha se houver dados (texto ou OCR j√° processado)
    try {
      // Se j√° tem dados processados do OCR, n√£o precisa reprocessar
      if (pastedSheetImage && headers.length && rowsAll.length) {
        console.log('‚úÖ Usando dados j√° processados pelo OCR');
        imageCacheByContact.clear();
        recountAndAutoselect();
      } else {
        // Processar normalmente se for texto
        const { headers: h0, rowsAoA } = extractFromEditable(sheetPaste);
        
        if (h0?.length && rowsAoA?.length) {
          const hdrRowValue = headerRowInput.value.trim();
          const fullArray = [h0, ...rowsAoA];
          let headerIndex = 0;
          
          if (hdrRowValue) {
            const num = parseInt(hdrRowValue, 10);
            if (Number.isInteger(num) && num >= 1 && num <= fullArray.length) {
              headerIndex = num - 1;
            }
          }
          
          const headersRow = fullArray[headerIndex] || fullArray[0];
          headers = headersRow.map(x => String(x || '').trim());
          
          const dataArray = fullArray
            .slice(headerIndex + 1)
            .filter(row => row.some(value => String(value).trim() !== ''));
          
          rowsAll = dataArray.map(row => {
            const obj = {};
            headers.forEach((header, idx) => {
              obj[header] = (row[idx] ?? '').toString().trim();
            });
            return obj;
          });
          
          imageCacheByContact.clear();
          
          const statsText = `Planilha: ${rowsAll.length} linha(s) ‚Ä¢ ${headers.length} coluna(s)`;
          el('#attachStats').textContent = statsText;
          el('#attachStats').className = 'badge success';
          
          el('#clearAttach').disabled = rowsAll.length === 0;
          el('#downloadZip').disabled = rowsAll.length === 0;
          
          console.log('‚úÖ Planilha reprocessada');
          
          recountAndAutoselect();
        } else {
          el('#attachStats').textContent = 'Sem dados';
          el('#attachStats').className = 'badge warning';
        }
        
        refreshPreviewFromEditable();
      }
    } catch (e) {
      console.error('Erro ao atualizar planilha:', e);
      showError('Falha ao atualizar dados colados', e?.message || String(e));
    }
    
    // 3. Atualizar preview
    await updatePreview();
    
    // 4. Regenerar output
    await regenerateOutput();
    
    log('‚úÖ Atualiza√ß√£o completa conclu√≠da!');
  }

  // Event listeners dos bot√µes de atualiza√ß√£o
  el('#refreshContacts').addEventListener('click', doFullRefresh);
  el('#refreshMsg').addEventListener('click', doFullRefresh);
  el('#refreshSheet').addEventListener('click', doFullRefresh);
  el('#refreshAll').addEventListener('click', doFullRefresh);

  /* ========================================
     INICIALIZA√á√ÉO FINAL
  ======================================== */
  console.log('‚úÖ Sistema inicializado');
  log('‚úÖ Pronto para uso!');
});
</script>
</body>
</html>